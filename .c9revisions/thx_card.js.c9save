{"ts":1342728905917,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n*ThxCard is a canvas-based thanks card for wedding or other party.\n*It allows the user to modified and get is own customised thanx card.\n*He can choose different background and different embedded photo of the event.\n*\n*/\n\n// START WRAPPER: The YUI.add wrapper is added by the build system, when you use YUI Builder to build your component from the raw source in this file\n// YUI.add(\"mywidget\", function(Y) {\nYUI().use('base', 'widget', 'node', 'substitute', 'console' ,'event', 'event-mousewheel', 'array-extras', function(Y) {\n    /* Any frequently used shortcuts, strings and constants */\n    var Lang = Y.Lang,\n    Widget = Y.Widget,\n    Node = Y.Node;\n\n    /* ThanksCard class constructor */\n    function ThanksCard(config) {\n        ThanksCard.superclass.constructor.apply(this, arguments);\n    }\n\n    /* \n    * Required NAME static field, to identify the Widget class and \n    * used as an event prefix, to generate class names etc. (set to the \n    * class name in camel case). \n*/\n    ThanksCard.NAME = \"thanksCard\";\n\n/*\n* The attribute configuration for the widget. This defines the core user facing state of the widget\n*/\n    ThanksCard.ATTRS = {\n\n        currentBG : {\n            value: 0  \n        },\n\n        currentPrimImg : {\n            value: 0\n        },\n\n        primImgRatio : {\n            value: 1\n        },\n\n        currentSecImg : {\n            value: 0\n        },\n\n        secImgRatio : {\n            value: 1\n        },\n\n        selectedFrame : {\n            value: 0\n        },\n\n        bgRatio : {\n            value : 1\n        },\n\n        listOfBGs : {\n            value : [\n                //{name: 'test',\n                //node: srcNode\n                //}\n            ]\n        },\n        listOfPrimImgs : {\n            value : [\n                //{name: 'test',\n                //node: srcNode\n                //}\n            ],\n            setter: function(val) { return this.setListOfImg(val, 'listOfPrimImgs'); }\n        },\n\n        listOfSecImgs : {\n            value : [\n                //{name: 'test',\n                //node: srcNode\n                //}\n            ],\n            setter: function(val) { return this.setListOfImg(val, 'listOfsecImgs'); }\n        },\n\n\n        ctx : {\n            writeOnce: true,\n            readOnly: true\n        },\n\n        width : {\n            value : 1772,\n            writeOnce: false\n        },\n\n        height : {\n            value : 1181,\n            writeOnce: false\n        }\n\n\n        // ... attrB, attrC, attrD ... attribute configurations. \n\n        // Can also include attributes for the super class if you want to override or add configuration parameters\n    };\n\n    /* \n    * The HTML_PARSER static constant is used if the Widget supports progressive enhancement, and is\n    * used to populate the configuration for the ThanksCard instance from markup already on the page.\n*/\n    ThanksCard.HTML_PARSER = {\n\n        //listOfBGs: function (srcNode) {\n        // If progressive enhancement is to be supported, return the value of \"currentBG\" based on the contents of the srcNode\n        //      srcNode.one('img')\n\n        //}\n\n    };\n\n    /* Templates for any markup the widget uses. Usually includes {} tokens, which are replaced through Y.substitute */\n    ThanksCard.MYNODE_TEMPLATE = \"<canvas id={mynodeid}></canvas>\";\n\n    /* ThanksCard extends the base Widget class */\n    Y.extend(ThanksCard, Y.Widget, {\n\n        initializer: function() {\n/*\n* initializer is part of the lifecycle introduced by \n* the Base class. It is invoked during construction,\n* and can be used to setup instance specific state or publish events which\n* require special configuration (if they don't need custom configuration, \n* events are published lazily only if there are subscribers).\n*\n* It does not need to invoke the superclass initializer. \n* init(zer() for all classes in the hierarchy.\n*/\n\n\n\n            this.publish(\"myEvent\", {\n                defaultFn: this._defMyEventFn,\n                bubbles:false\n            });\n        },\n\n        destructor : function() {\n/*\n* destructor is part of the lifecycle introduced by \n* the Widget class. It is invoked during destruction,\n* and can be used to cleanup instance specific state.\n*\n* Anything under the boundingBox will be cleaned up by the Widget base class\n* We only need to clean up nodes/events attached outside of the bounding Box\n*\n* It does not need to invoke the superclass destructor. \n* destroy() will call initializer() for all classes in the hierarchy.\n*/\n        },\n\n        renderUI : function() {\n/*\n* renderUI is part of the lifecycle introduced by the\n* Widget class. Widget's renderer method invokes:\n*\n*     renderUI()\n*     bindUI()\n*     syncUI()\n*\n* renderUI is intended to be used by the Widget subclass\n* to create or insert new elements into the DOM. \n*/\n\n            //TODO create  the canvas, set its size\n            var contentBox = this.get(\"contentBox\");\n            this._mynode = Node.create(Y.substitute(ThanksCard.MYNODE_TEMPLATE, {mynodeid: this.get(\"id\") + \"_mynode\"})); \n            //this._mynode.setAttribute('width', this.get('width')+'px');\n            //this._mynode.setAttribute('height', this.get('height')+'px');\n            var body = Y.one('body'),\n            winWidth = body.get('winWidth'),\n            winHeight  = body.get('winHeight');\n            this._mynode.setAttribute('width', winWidth);\n            this._mynode.setAttribute('height', winHeight );\n            this._set('ctx', this._mynode.getDOMNode().getContext('2d'));\n            //TODO insert the node\n            this.set('width', winWidth);\n            this.set('height', winHeight);\n\n            contentBox.appendChild(this._mynode);\n\n        },\n\n        bindUI : function() {\n/*\n* bindUI is intended to be used by the Widget subclass \n* to bind any event listeners which will drive the Widget UI.\n* \n* It will generally bind event listeners for attribute change\n* events, to update the state of the rendered UI in response \n* to attribute value changes, and also attach any DOM events,\n* to activate the UI.\n*/\n\n            Y.log('bind UI event');\n            this.after(\"currentBGChange\", this._afterCurrentBGChange);\n            this.after(\"currentPrimImgChange\", this._afterCurrentPrimImgChange);\n            this.after(\"currentSecImgChange\", this._afterCurrentSecImgChange);\n            this.after(\"primImgRatioChange\", this._afterPrimImgRatioChange);\n            this.after(\"secImgRatioChange\", this._afterSecImgRatioChange);\n        },\n\n        syncUI : function() {\n/*\n* syncUI is intended to be used by the Widget subclass to\n* update the UI to reflect the initial state of the widget,\n* after renderUI. From there, the event listeners we bound above\n* will take over.\n*/\n\n            // set default background, and default embedded photo and text\n            this._uiSetCurrentBG(this.get(\"currentBG\"));\n        },\n\n        // Beyond this point is the ThanksCard specific application and rendering logic\n\n        /* Attribute state supporting methods (see attribute config above) */\n        _afterCurrentBGChange : function(e) {\n            /* Listens for changes in state, and asks for a UI update (controller). */\n\n            this._uiSetCurrentBG(e.newVal);\n        },\n\n        _uiSetCurrentBG : function(imgIndex) {\n            /* Update the state of currentBG in the UI (view) */\n            this._drawScene(imgIndex, this.get('currentPrimImg'), this.get('currentSecImg')); \n        },\n\n        _afterCurrentPrimImgChange : function(e) {\n            /* Listens for changes in state, and asks for a UI update (controller). */\n\n            this._uiSetCurrentPrimImg(e.newVal);\n        },\n\n        _uiSetCurrentPrimImg : function(imgIndex) {\n            /* Update the state of currentBG in the UI (view) */\n            this._drawScene( this.get('currentBG'), imgIndex, this.get('currentSecImg')); \n        },\n\n        _afterCurrentSecImgChange : function(e) {\n            /* Listens for changes in state, and asks for a UI update (controller). */\n\n            this._uiSetCurrentSecImg(e.newVal);\n        },\n\n        _uiSetCurrentSecImg : function(imgIndex) {\n            /* Update the state of currentBG in the UI (view) */\n            this._drawScene( this.get('currentBG'), this.get('currentPrimImg'), imgIndex); \n        },\n\n\n        _afterPrimImgRatioChange : function(e) {\n            Y.log('after PrimImgRatio change');\n            this._uiSetPrimImgRatioChange(e.newVal);\n        },\n\n        _uiSetPrimImgRatioChange : function(imgIndex) {\n            this._drawScene( this.get('currentBG'), this.get('currentPrimImg'), this.get('currentSecImg')); \n        },\n  _afterSecImgRatioChange : function(e) {\n            Y.log('after SecImgRatio change');\n            this._uiSetSecImgRatioChange(e.newVal);\n        },\n\n        _uiSetSecImgRatioChange : function(imgIndex) {\n            this._drawScene( this.get('currentBG'), this.get('currentPrimImg'), this.get('currentSecImg')); \n        },\n\n\n        setListOfImg : function (elClass, argName) {\n            var imgs = Y.all(elClass);\n            Y.log('Setting images for ' + argName);\n                var listOfImgs = [];\n            imgs.each(function (item) {\n                this.push({\n                    node: item, \n                    name: item.get('name') || 'NoName'\n                });\n            }, listOfImgs);\n            return listOfImgs; \n        },\n\n\n\n\n/*\n*Draw the background.\n*Make it fit in the viewport\n*/\n\n        _drawBG : function (img) {\n            var ctx = this.get('ctx'),\n            width = img.width,\n            height = img.height,\n            ratio = this.get('bgRatio');\n            ctx.drawImage(img, 0, 0, width * ratio, height * ratio );\n            ctx.save();\n            ctx.scale(ratio,ratio);\n            ctx.drawImage(img, 0, 0);\n            ctx.restore();\n        },\n\n        /**\n         *Draw the whole canvas with bg, primary and secondary img\n         * whose index is passed as arg\n*/\n        _drawScene : function (bgIndex, primImgIndex, secImgIndex){\n            Y.log('_drawScene: ' + bgIndex + ', ' + primImgIndex + ', ' + secImgIndex);\n            var img = this.get('listOfBGs')[bgIndex];\n\n            var imgName = img.name;\n            img = img.node.getDOMNode(),\n            ratio = this.computeRatio(img.width, img.height, this.get('width'), this.get('height'));\n            this.set('bgRatio', ratio);\n\n            this._drawWhiteBlank();\n            this._drawImage(this.get('listOfPrimImgs')[primImgIndex], 0);\n            this._drawImage(this.get('listOfSecImgs')[secImgIndex], 1);\n            this._drawBG(img);\n\n        },\n\n/*\n*erase the whole canvas\n*/\n        _drawWhiteBlank: function() {\n            var ctx = this.get('ctx');\n            Y.log('drawWithBlank');\n            ctx.clearRect(0, 0, this.get('width') , this.get('height') );\n\n        },\n\n        /**\n        *draw an image, at the position and angle \n        * specified by the BG information\n*/\n        _drawImage : function (img, frameNumber) {\n            var ctx = this.get('ctx'),\n            ratio = this.get('bgRatio'),\n            bgIndex = this.get('currentBG'),\n            bg=this.get('listOfBGs')[bgIndex],\n            frameNumber = frameNumber || 0;\n\n            var frameName = ['prim', 'sec'][frameNumber],\n            coord = frameName + 'Coord', \n            ratioName = frameName + 'ImgRatio',\n            transX = bg[coord].x,\n            transY = bg[coord].y,\n            photoframe_width = bg[coord].width,\n            photoframe_height = bg[coord].height,\n            img = img.node.getDOMNode(), \n            angle = bg[coord].angle;\n            //setup the context, \n            //scale according to the bg scale\n            //translate to the photo frame position\n            //and rotate like the photo frame\n            //finally we clip to the size of thphoto frame\n            ctx.save();\n            ctx.scale(ratio, ratio);\n            ctx.translate(transX, transY);\n            ctx.rotate(angle);\n\n            ctx.beginPath();\n            ctx.lineTo(photoframe_width, 0);\n            ctx.lineTo(photoframe_width, photoframe_height);\n            ctx.lineTo(0, photoframe_height);\n            ctx.lineTo(0, 0);\n            ctx.clip();\n\n            ratio = this.computeRatio(img.width, img.height, photoframe_width, photoframe_height);\n            ratio = ratio * this.get(ratioName);\n            ctx.scale(ratio, ratio);\n            ctx.drawImage(img, 0, 0);\n            ctx.restore(); \n        },\n\n        computeRatio : function (x,y,xref,yref){\n            Y.log('computeRatio ' + x + ',' + y +', ' + xref + ', ' + yref);\n            var xRatio = xref / x,\n            yRatio = yref / y,\n            ratio = 1;\n\n\n            if (xRatio < 1 || yRatio < 1) {\n                //we need to reduce size of img\n                ratio = (xRatio < yRatio)? xRatio : yRatio; \n            } \n            return ratio;\n\n        },\n\n        nextBG : function() {\n            var nextBG = this.get('currentBG') + 1;\n            if (nextBG >= this.get('listOfBGs').length){\n                nextBG = 0;\n            }\n            this.set('currentBG', nextBG);\n            Y.log('New BG is ' + nextBG);\n\n        },\n        nextPrimImgs : function() {\n            var nextImg = this.get('currentPrimImg') + 1;\n            if (nextImg >= this.get('listOfPrimImgs').length){\n                nextImg = 0;\n            }\n            this.set('currentPrimImg', nextImg);\n            Y.log('New Primary Img is ' + nextImg);\n        },\n        nextSecImgs : function() {\n            var nextImg = this.get('currentSecImg') + 1;\n            if (nextImg >= this.get('listOfSecImgs').length){\n                nextImg = 0;\n            }\n            this.set('currentSecImg', nextImg);\n            Y.log('New Secondary Img is ' + nextImg);\n        },\n\n/*\n*switch between the frames 0 and 1\n*/\n        nextFrame : function() {\n            var prev = this.get('selectedFrame');\n            this.set('selectedFrame', ((prev == 0 )?1:0)); \n        },\n\n        nextPhotoFrame : function() {\n            [this.nextPrimImgs ,this.nextSecImgs][this.get('selectedFrame')].call(this);\n        },\n\n\n        primImgZoomHandler : function(scrollEvt){\n            var delta = 0.01 *scrollEvt.wheelDelta,\n            ratio = this.get('primImgRatio');\n            Y.log('new primImgRatio = ' + ratio);\n            this.set('primImgRatio', ratio+delta);\n        },\n\n\n        secImgZoomHandler : function(scrollEvt){\n            var delta = 0.01 *scrollEvt.wheelDelta,\n            ratio = this.get('secImgRatio');\n            Y.log('new secImgRatio = ' + ratio);\n            this.set('secImgRatio', ratio+delta);\n        },\n\n        selectedFrameZoomHandler : function(evt) {\n            [this.primImgZoomHandler ,this.secImgZoomHandler][this.get('selectedFrame')].call(this, evt);\n        },\n\n\n\n    });\n\n    Y.namespace(\"Thx\").ThanksCard = ThanksCard;\n\n    // }, \"3.2.0\", {requires:[\"widget\", \"substitute\"]});\n    // END WRAPPER\n    Y.on('domready', function(){\n        var thx = new ThanksCard({\n            srcNode: \"#container\",\n            listOfBGs :[\n                {\n                name: 'test1',\n                node: Y.one('#bg_img1'),\n                primCoord: {x:525, y:250, width:595, height: 600, angle:0.261},\n                secCoord: {x:1249, y:240, width:595, height: 525, angle:0.174}\n            },\n            {\n                name: 'test2',\n                node: Y.one('#bg_img2'),\n                primCoord: {x:210, y:305, width:320, height: 310, angle:0},\n                secCoord: {x:1185, y:448, width:470, height: 475, angle:0}\n\n            }]/*,\n            listOfPrimImgs : [{\n            name: 'castle',\n            node: Y.one('#castle')\n            },\n            {\n            name: 'kenting',\n            node: Y.one('#kenting')\n            },\n            {\n            name: 'hairdress',\n            node: Y.one('#hairdress')\n            },\n            {\n            name: 'appart',\n            node: Y.one('#appart')\n            },           \n            ]\n*/\n        });\n        Y.log('Thx card inited\\nset list of imgs...');\n        thx.set('listOfSecImgs', '.secPhoto');\n        thx.set('listOfPrimImgs', '.primPhoto');\n        thx.render();\n        Y.one('body').on('key', function (e) {\n            thx.nextPhotoFrame();\n        }, 'down:enter');\n\n        Y.one('body').on('key', function (e) {\n            e.preventDefault();\n            thx.nextFrame();\n        }, 'down:tab');\n\n        Y.one('body').on('key', function (e) { \n            thx.nextBG();\n        }, 'down:8');\n        Y.one('body').on('mousewheel', function (e) { \n            Y.log('event mousewheel'); \n            thx.selectedFrameZoomHandler(e);\n        });\n\n\n    });\n});\n\n"]],"start1":0,"start2":0,"length1":0,"length2":16737}]],"length":16737}
{"contributors":[],"silentsave":false,"ts":1343558315281,"patch":[[{"diffs":[[0,"to modif"],[-1,"ied"],[1,"y"],[0," and get"]],"start1":90,"start2":90,"length1":19,"length2":17},{"diffs":[[0,"{\n  "],[-1,"  /* Any frequently used shortcuts, strings and constants */\n    var Lang = Y.Lang,\n    Widget = Y.Widget,\n    Node = Y.Node;\n\n    /* ThanksCard class constructor */\n    function ThanksCard(config) {\n        ThanksCard.superclass.constructor.apply(this, arguments);\n    }\n\n    /* \n    * Required NAME static field, to identify the Widget class and \n    * used as an event prefix, to generate class names etc. (set to the \n    * class name in camel case). \n*/\n    ThanksCard.NAME = \"thanksCard\";\n\n/*\n* The attribute configuration for the widget. This defines the core user facing state of the widget\n*/\n    ThanksCard.ATTRS = {\n\n        currentBG : {\n            value: 0  \n        },\n\n        currentPrimImg : {\n            value: 0\n        },\n\n        primImgRatio : {\n            value: 1\n        },\n\n        currentSecImg : {\n            value: 0\n        },\n\n        secImgRatio : {\n            value: 1\n        },\n\n        selectedFrame : {\n            value: 0\n        },\n\n        bgRatio : {\n            value : 1\n        },\n\n        listOfBGs : {\n            value : [\n                //{name: 'test',\n                //node: srcNode\n                //}\n            ]\n        },\n        listOfPrimImgs : {\n            value : [\n                //{name: 'test',\n                //node: srcNode\n                //}\n            ],\n            setter: function(val) { return this.setListOfImg(val, 'listOfPrimImgs'); }\n        },\n\n        listOfSecImgs : {\n            value : [\n                //{name: 'test',\n                //node: srcNode\n                //}\n            ],\n            setter: function(val) { return this.setListOfImg(val, 'listOfsecImgs'); }\n        },\n\n\n        ctx : {\n            writeOnce: true,\n            readOnly: true\n        },\n\n        width : {\n            value : 1772,\n            writeOnce: false\n        },\n\n        height : {\n            value : 1181,\n            writeOnce: false\n        }\n\n\n        // ... attrB, attrC, attrD ... attribute configurations. \n\n        // Can also include attributes for the super class if you want to override or add configuration parameters\n    };\n\n    /* \n    * The HTML_PARSER static constant is used if the Widget supports progressive enhancement, and is\n    * used to populate the configuration for the ThanksCard instance from markup already on the page.\n*/\n    ThanksCard.HTML_PARSER = {\n\n        //listOfBGs: function (srcNode) {\n        // If progressive enhancement is to be supported, return the value of \"currentBG\" based on the contents of the srcNode\n        //      srcNode.one('img')\n\n        //}\n\n    };\n\n    /* Templates for any markup the widget uses. Usually includes {} tokens, which are replaced through Y.substitute */\n    ThanksCard.MYNODE_TEMPLATE = \"<canvas id={mynodeid}></canvas>\";\n\n    /* ThanksCard extends the base Widget class */\n    Y.extend(ThanksCard, Y.Widget, {\n\n        initializer: function() {\n/*\n* initializer is part of the lifecycle introduced by \n* the Base class. It is invoked during construction,\n* and can be used to setup instance specific state or publish events which\n* require special configuration (if they don't need custom configuration, \n* events are published lazily only if there are subscribers).\n*\n* It does not need to invoke the superclass initializer. \n* init(zer() for all classes in the hierarchy.\n*/\n\n\n\n            this.publish(\"myEvent\", {\n                defaultFn: this._defMyEventFn,\n                bubbles:false\n            });\n        },\n\n        destructor : function() {\n/*\n* destructor is part of the lifecycle introduced by \n* the Widget class. It is invoked during destruction,\n* and can be used to cleanup instance specific state.\n*\n* Anything under the boundingBox will be cleaned up by the Widget base class\n* We only need to clean up nodes/events attached outside of the bounding Box\n*\n* It does not need to invoke the superclass destructor. \n* destroy() will call initializer() for all classes in the hierarchy.\n*/\n        },\n\n        renderUI : function() {\n/*\n* renderUI is part of the lifecycle introduced by the\n* Widget class. Widget's renderer method invokes:\n*\n*     renderUI()\n*     bindUI()\n*     syncUI()\n*\n* renderUI is intended to be used by the Widget subclass\n* to create or insert new elements into the DOM. \n*/\n\n            //TODO create  the canvas, set its size\n            var contentBox = this.get(\"contentBox\");\n            this._mynode = Node.create(Y.substitute(ThanksCard.MYNODE_TEMPLATE, {mynodeid: this.get(\"id\") + \"_mynode\"})); \n            //this._mynode.setAttribute('width', this.get('width')+'px');\n            //this._mynode.setAttribute('height', this.get('height')+'px');\n            var body = Y.one('body'),\n            winWidth = body.get('winWidth'),\n            winHeight  = body.get('winHeight');\n            this._mynode.setAttribute('width', winWidth);\n            this._mynode.setAttribute('height', winHeight );\n            this._set('ctx', this._mynode.getDOMNode().getContext('2d'));\n            //TODO insert the node\n            this.set('width', winWidth);\n            this.set('height', winHeight);\n\n            contentBox.appendChild(this._mynode);\n\n        },\n\n        bindUI : function() {\n/*\n* bindUI is intended to be used by the Widget subclass \n* to bind any event listeners which will drive the Widget UI.\n* \n* It will generally bind event listeners for attribute change\n* events, to update the state of the rendered UI in response \n* to attribute value changes, and also attach any DOM events,\n* to activate the UI.\n*/\n\n            Y.log('bind UI event');\n            this.after(\"currentBGChange\", this._afterCurrentBGChange);\n            this.after(\"currentPrimImgChange\", this._afterCurrentPrimImgChange);\n            this.after(\"currentSecImgChange\", this._afterCurrentSecImgChange);\n            this.after(\"primImgRatioChange\", this._afterPrimImgRatioChange);\n            this.after(\"secImgRatioChange\", this._afterSecImgRatioChange);\n        },\n\n        syncUI : function() {\n/*\n* syncUI is intended to be used by the Widget subclass to\n* update the UI to reflect the initial state of the widget,\n* after renderUI. From there, the event listeners we bound above\n* will take over.\n*/\n\n            // set default background, and default embedded photo and text\n            this._uiSetCurrentBG(this.get(\"currentBG\"));\n        },\n\n        // Beyond this point is the ThanksCard specific application and rendering logic\n\n        /* Attribute state supporting methods (see attribute config above) */\n        _afterCurrentBGChange : function(e) {\n            /* Listens for changes in state, and asks for a UI update (controller). */\n\n            this._uiSetCurrentBG(e.newVal);\n        },\n\n        _uiSetCurrentBG : function(imgIndex) {\n            /* Update the state of currentBG in the UI (view) */\n            this._drawScene(imgIndex, this.get('currentPrimImg'), this.get('currentSecImg')); \n        },\n\n        _afterCurrentPrimImgChange : function(e) {\n            /* Listens for changes in state, and asks for a UI update (controller). */\n\n            this._uiSetCurrentPrimImg(e.newVal);\n        },\n\n        _uiSetCurrentPrimImg : function(imgIndex) {\n            /* Update the state of currentBG in the UI (view) */\n            this._drawScene( this.get('currentBG'), imgIndex, this.get('currentSecImg')); \n        },\n\n        _afterCurrentSecImgChange : function(e) {\n            /* Listens for changes in state, and asks for a UI update (controller). */\n\n            this._uiSetCurrentSecImg(e.newVal);\n        },\n\n        _uiSetCurrentSecImg : function(imgIndex) {\n            /* Update the state of currentBG in the UI (view) */\n            this._drawScene( this.get('currentBG'), this.get('currentPrimImg'), imgIndex); \n        },\n\n\n        _afterPrimImgRatioChange : function(e) {\n            Y.log('after PrimImgRatio change');\n            this._uiSetPrimImgRatioChange(e.newVal);\n        },\n\n        _uiSetPrimImgRatioChange : function(imgIndex) {\n            this._drawScene( this.get('currentBG'), this.get('currentPrimImg'), this.get('currentSecImg')); \n        },\n  _afterSecImgRatioChange : function(e) {\n            Y.log('after SecImgRatio change');\n            this._uiSetSecImgRatioChange(e.newVal);\n        },\n\n        _uiSetSecImgRatioChange : function(imgIndex) {\n            this._drawScene( this.get('currentBG'), this.get('currentPrimImg'), this.get('currentSecImg')); \n        },\n\n\n        setListOfImg : function (elClass, argName) {\n            var imgs = Y.all(elClass);\n            Y.log('Setting images for ' + argName);\n                var listOfImgs = [];\n            imgs.each(function (item) {\n                this.push({\n                    node: item, \n                    name: item.get('name') || 'NoName'\n                });\n            }, listOfImgs);\n            return listOfImgs; \n        },\n\n\n\n\n/*\n*Draw the background.\n*Make it fit in the viewport\n*/\n\n        _drawBG : function (img) {\n            var ctx = this.get('ctx'),\n            width = img.width,\n            height = img.height,\n            ratio = this.get('bgRatio');\n            ctx.drawImage(img, 0, 0, width * ratio, height * ratio );\n            ctx.save();\n            ctx.scale(ratio,ratio);\n            ctx.drawImage(img, 0, 0);\n            ctx.restore();\n        },\n\n        /**\n         *Draw the whole canvas with bg, primary and secondary img\n         * whose index is passed as arg\n*/\n        _drawScene : function (bgIndex, primImgIndex, secImgIndex){\n            Y.log('_drawScene: ' + bgIndex + ', ' + primImgIndex + ', ' + secImgIndex);\n            var img = this.get('listOfBGs')[bgIndex];\n\n            var imgName = img.name;\n            img = img.node.getDOMNode(),\n            ratio = this.computeRatio(img.width, img.height, this.get('width'), this.get('height'));\n            this.set('bgRatio', ratio);\n\n            this._drawWhiteBlank();\n            this._drawImage(this.get('listOfPrimImgs')[primImgIndex], 0);\n            this._drawImage(this.get('listOfSecImgs')[secImgIndex], 1);\n            this._drawBG(img);\n\n        },\n\n/*\n*erase the whole canvas\n*/\n        _drawWhiteBlank: function() {\n            var ctx = this.get('ctx');\n            Y.log('drawWithBlank');\n            ctx.clearRect(0, 0, this.get('width') , this.get('height') );\n\n        },\n\n        /**\n        *draw an image, at the position and angle \n        * specified by the BG information\n*/\n        _drawImage : function (img, frameNumber) {\n            var ctx = this.get('ctx'),\n            ratio = this.get('bgRatio'),\n            bgIndex = this.get('currentBG'),\n            bg=this.get('listOfBGs')[bgIndex],\n            frameNumber = frameNumber || 0;\n\n            var frameName = ['prim', 'sec'][frameNumber],\n            coord = frameName + 'Coord', \n            ratioName = frameName + 'ImgRatio',\n            transX = bg[coord].x,\n            transY = bg[coord].y,\n            photoframe_width = bg[coord].width,\n            photoframe_height = bg[coord].height,\n            img = img.node.getDOMNode(), \n            angle = bg[coord].angle;\n            //setup the context, \n            //scale according to the bg scale\n            //translate to the photo frame position\n            //and rotate like the photo frame\n            //finally we clip to the size of thphoto frame\n            ctx.save();\n            ctx.scale(ratio, ratio);\n            ctx.translate(transX, transY);\n            ctx.rotate(angle);\n\n            ctx.beginPath();\n            ctx.lineTo(photoframe_width, 0);\n            ctx.lineTo(photoframe_width, photoframe_height);\n            ctx.lineTo(0, photoframe_height);\n            ctx.lineTo(0, 0);\n            ctx.clip();\n\n            ratio = this.computeRatio(img.width, img.height, photoframe_width, photoframe_height);\n            ratio = ratio * this.get(ratioName);\n            ctx.scale(ratio, ratio);\n            ctx.drawImage(img, 0, 0);\n            ctx.restore(); \n        },\n\n        computeRatio : function (x,y,xref,yref){\n            Y.log('computeRatio ' + x + ',' + y +', ' + xref + ', ' + yref);\n            var xRatio = xref / x,\n            yRatio = yref / y,\n            ratio = 1;\n\n\n            if (xRatio < 1 || yRatio < 1) {\n                //we need to reduce size of img\n                ratio = (xRatio < yRatio)? xRatio : yRatio; \n            } \n            return ratio;\n\n        },\n\n        nextBG : function() {\n            var nextBG = this.get('currentBG') + 1;\n            if (nextBG >= this.get('listOfBGs').length){\n                nextBG = 0;\n            }\n            this.set('currentBG', nextBG);\n            Y.log('New BG is ' + nextBG);\n\n        },\n        nextPrimImgs : function() {\n            var nextImg = this.get('currentPrimImg') + 1;\n            if (nextImg >= this.get('listOfPrimImgs').length){\n                nextImg = 0;\n            }\n            this.set('currentPrimImg', nextImg);\n            Y.log('New Primary Img is ' + nextImg);\n        },\n        nextSecImgs : function() {\n            var nextImg = this.get('currentSecImg') + 1;\n            if (nextImg >= this.get('listOfSecImgs').length){\n                nextImg = 0;\n            }\n            this.set('currentSecImg', nextImg);\n            Y.log('New Secondary Img is ' + nextImg);\n        },\n\n/*\n*switch between the frames 0 and 1\n*/\n        nextFrame : function() {\n            var prev = this.get('selectedFrame');\n            this.set('selectedFrame', ((prev == 0 )?1:0)); \n        },\n\n        nextPhotoFrame : function() {\n            [this.nextPrimImgs ,this.nextSecImgs][this.get('selectedFrame')].call(this);\n        },\n\n\n        primImgZoomHandler : function(scrollEvt){\n            var delta = 0.01 *scrollEvt.wheelDelta,\n            ratio = this.get('primImgRatio');\n            Y.log('new primImgRatio = ' + ratio);\n            this.set('primImgRatio', ratio+delta);\n        },\n\n\n        secImgZoomHandler : function(scrollEvt){\n            var delta = 0.01 *scrollEvt.wheelDelta,\n            ratio = this.get('secImgRatio');\n            Y.log('new secImgRatio = ' + ratio);\n            this.set('secImgRatio', ratio+delta);\n        },\n\n        selectedFrameZoomHandler : function(evt) {\n            [this.primImgZoomHandler ,this.secImgZoomHandler][this.get('selectedFrame')].call(this, evt);\n        },\n\n\n\n    });\n\n    Y.namespace(\"Thx\").ThanksCard = ThanksCard;\n\n    // }, \"3.2.0\", {requires:[\"widget\", \"substitute\"]});\n    // END WRAPPER\n    Y.on('domready', function(){\n        var thx = new ThanksCard({\n            srcNode: \"#container\",\n            listOfBGs :[\n                {\n                name: 'test1',\n                node: Y.one('#bg_img1'),\n                primCoord: {x:525, y:250, width:595, height: 600, angle:0.261},\n                secCoord: {x:1249, y:240, width:595, height: 525, angle:0.174}\n            },\n            {\n                name: 'test2',\n                node: Y.one('#bg_img2'),\n                primCoord: {x:210, y:305, width:320, height: 310, angle:0},\n                secCoord: {x:1185, y:448, width:470, height: 475, angle:0}\n\n            }]/*,\n            listOfPrimImgs : [{\n            name: 'castle',\n            node: Y.one('#castle')\n            },\n            {\n            name: 'kenting',\n            node: Y.one('#kenting')\n            },\n            {\n            name: 'hairdress',\n            node: Y.one('#hairdress')\n            },\n            {\n            name: 'appart',\n            node: Y.one('#appart')\n            },           \n            ]\n*/\n        });\n        Y.log('Thx card inited\\nset list of imgs...');\n        thx.set('listOfSecImgs', '.secPhoto');\n        thx.set('listOfPrimImgs', '.primPhoto');\n        thx.render();\n        Y.one('body').on('key', function (e) {\n            thx.nextPhotoFrame();\n        }, 'down:enter');\n\n        Y.one('body').on('key', function (e) {\n            e.preventDefault();\n            thx.nextFrame();\n        }, 'down:tab');\n\n        Y.one('body').on('key', function (e) { \n            thx.nextBG();\n        }, 'down:8');\n        Y.one('body').on('mousewheel', function (e) { \n            Y.log('event mousewheel'); \n            thx.selectedFrameZoomHandler(e);\n        });\n\n\n    });\n});\n"],[1,"/* Any frequently used shortcuts, strings and constants */\n  var Lang = Y.Lang,\n  Widget = Y.Widget,\n  Node = Y.Node;\n\n  /** ThanksCard class constructor\n  *@class ThanksCard\n  *@constructor\n  *\n  * */\n  function ThanksCard(config) {\n    ThanksCard.superclass.constructor.apply(this, arguments);\n  }\n\n  /* \n  * Required NAME static field, to identify the Widget class and \n  * used as an event prefix, to generate class names etc. (set to the \n  * class name in camel case). \n  */\n  ThanksCard.NAME = \"thanksCard\";\n\n  /*\n  * The attribute configuration for the widget. This defines the core user facing state of the widget\n  */\n  ThanksCard.ATTRS = {\n\n    currentBG : {\n      value: 0  \n    },\n\n    /*a list of current frames images.\n    * default should be [0]\n    *  if undefined should return 0\n    */\n    currentFrameImgs : {\n      value: [0]\n    },\n\n    //list of images ratio. default is 1\n    imgsRatio : {\n      value: [1]\n    },\n    //the image frame that will be modified with a nextImg\n    selectedFrame : {\n      value: 0\n    },\n\n    bgRatio : {\n      value : 1\n    },\n\n    //the list of background images\n    listOfBGs : {\n      value : [\n        /*   [{\n          *    name: 'test1',\n          *node: Y.one('#bg_img1'),\n          *    coord: [{x:525, y:250, width:595, height: 600, angle:0.261},\n          *    {x:1249, y:240, width:595, height: 525, angle:0.174}]\n          *  }]\n          */  \n          //}\n      ]\n    },\n\n    //the list of images\n    listOfImgs : {\n      value : [[\n        //{name: 'test',\n          //node: srcNode\n          //}\n      ]],\n      setter: function(val, valName) { \n        Y.log('Setting ' + valName + ' to ' + val);\n        return this.setAllListsOfImg(val); }\n    },\n\n    ctx : {\n      writeOnce: true,\n      readOnly: true\n    },\n\n    width : {\n      value : 1772,\n      writeOnce: false\n    },\n\n    height : {\n      value : 1181,\n      writeOnce: false\n    }\n\n\n    // ... attrB, attrC, attrD ... attribute configurations. \n\n    // Can also include attributes for the super class if you want to override or add configuration parameters\n  };\n\n  /* \n  * The HTML_PARSER static constant is used if the Widget supports progressive enhancement, and is\n  * used to populate the configuration for the ThanksCard instance from markup already on the page.\n  */\n  ThanksCard.HTML_PARSER = {\n\n    //listOfBGs: function (srcNode) {\n      // If progressive enhancement is to be supported, return the value of \"currentBG\" based on the contents of the srcNode\n      //      srcNode.one('img')\n\n      //}\n\n  };\n\n  /* Templates for any markup the widget uses. Usually includes {} tokens, which are replaced through Y.substitute */\n  ThanksCard.MYNODE_TEMPLATE = \"<canvas id={mynodeid}></canvas>\";\n\n  /* ThanksCard extends the base Widget class */\n  Y.extend(ThanksCard, Y.Widget, {\n\n    initializer: function() {\n      /*\n      * initializer is part of the lifecycle introduced by \n      * the Base class. It is invoked during construction,\n      * and can be used to setup instance specific state or publish events which\n      * require special configuration (if they don't need custom configuration, \n      * events are published lazily only if there are subscribers).\n      *\n      * It does not need to invoke the superclass initializer. \n      * init(zer() for all classes in the hierarchy.\n      */\n\n\n\n      this.publish(\"myEvent\", {\n        defaultFn: this._defMyEventFn,\n        bubbles:false\n      });\n    },\n\n    destructor : function() {\n      /*\n      * destructor is part of the lifecycle introduced by \n      * the Widget class. It is invoked during destruction,\n      * and can be used to cleanup instance specific state.\n      *\n      * Anything under the boundingBox will be cleaned up by the Widget base class\n      * We only need to clean up nodes/events attached outside of the bounding Box\n      *\n      * It does not need to invoke the superclass destructor. \n      * destroy() will call initializer() for all classes in the hierarchy.\n      */\n    },\n\n    renderUI : function() {\n      /*\n      * renderUI is part of the lifecycle introduced by the\n      * Widget class. Widget's renderer method invokes:\n      *\n      *     renderUI()\n      *     bindUI()\n      *     syncUI()\n      *\n      * renderUI is intended to be used by the Widget subclass\n      * to create or insert new elements into the DOM. \n      */\n\n      var contentBox = this.get(\"contentBox\"),\n      body = Y.one('body'),\n      winWidth = body.get('winWidth'),\n      winHeight  = body.get('winHeight');\n      this._mynode = Node.create(Y.substitute(ThanksCard.MYNODE_TEMPLATE, {mynodeid: this.get(\"id\") + \"_mynode\"})); \n      //this._mynode.setAttribute('width', this.get('width')+'px');\n      //this._mynode.setAttribute('height', this.get('height')+'px');\n      this._mynode.setAttribute('width', winWidth);\n      this._mynode.setAttribute('height', winHeight );\n      this._set('ctx', this._mynode.getDOMNode().getContext('2d'));\n      //TODO insert the node\n      this.set('width', winWidth);\n      this.set('height', winHeight);\n\n      contentBox.appendChild(this._mynode);\n\n    },\n\n    bindUI : function() {\n      /*\n      * bindUI is intended to be used by the Widget subclass \n      * to bind any event listeners which will drive the Widget UI.\n      * \n      * It will generally bind event listeners for attribute change\n      * events, to update the state of the rendered UI in response \n      * to attribute value changes, and also attach any DOM events,\n      * to activate the UI.\n      */\n\n      Y.log('bind UI event');\n      this.after(\"currentBGChange\", this._afterCurrentBGChange);\n      this.after(\"currentFrameImgsChange\", this._afterCurrentFrameImgsChange);\n      this.after(\"imgsRatioChange\", this._afterImgsRatioChange);\n    },\n\n    syncUI : function() {\n      /*\n      * syncUI is intended to be used by the Widget subclass to\n      * update the UI to reflect the initial state of the widget,\n      * after renderUI. From there, the event listeners we bound above\n      * will take over.\n      */\n\n      // set default background, and default embedded photo and text\n      this._uiSetCurrentBG(this.get(\"currentBG\"));\n    },\n\n    // Beyond this point is the ThanksCard specific application and rendering logic\n\n    /* Attribute state supporting methods (see attribute config above) */\n    _afterCurrentBGChange : function(e) {\n      /* Listens for changes in state, and asks for a UI update (controller). */\n\n      this._uiSetCurrentBG(e.newVal);\n    },\n\n    _uiSetCurrentBG : function(currentBGIndex) {\n      /* Update the state of currentBG in the UI (view) */\n      //this._drawScene(imgIndex, this.get('currentBG'), this.get('currentFrameImgs')); \n      this._drawScene(currentBGIndex,  this.get('currentFrameImgs')); \n    },\n\n    _afterCurrentFrameImgsChange : function(e) {\n      /* Listens for changes in state, and asks for a UI update (controller). */\n\n      this._uiSetCurrentFrameImgs(e.newVal);\n    },\n\n    _uiSetCurrentFrameImgs : function(imgIndex) {\n      /* Update the state of currentBG in the UI (view) */\n      this._drawScene( this.get('currentBG'), this.get('currentFrameImgs')); \n    },\n\n\n    _afterImgsRatioChange : function(e) {\n      Y.log('after ImgsRatio change');\n      this._uiSetImgsRatioChange(e.newVal);\n    },\n\n    _uiSetImgsRatioChange : function(imgIndex) {\n      this._drawScene( this.get('currentBG'), this.get('currentFrameImgs')); \n    },\n\n    /**\n    *setter for listsOfImg\n    */\n    setAllListsOfImg : function(classesList){\n      var res = [];\n      Y.Array.each(classesList, function(it, i) {\n        res.push(this.setListOfImg(it, i));\n      }, this);\n      return res;\n    },\n\n    /**\n    *set List of img for frame number argName\n    * @method setLIstOfImg\n    *\n    * @param argName index of frame the list of img is for\n    * @param elClass class of images to put in that list\n    *\n    */\n    setListOfImg : function (elClass, argName) {\n      var imgs = Y.all(elClass);\n      Y.log('Setting images for ' + argName);\n      var listOfImgs = [];\n      imgs.each(function (item) {\n        this.push({\n          node: item, \n          name: item.get('name') || 'NoName'\n        });\n      }, listOfImgs);\n      if (Y.Lang.isNumber(argName)){\n        var tmp = this.get('listOfImgs') || [];\n        tmp[argName] = listOfImgs;\n      }\n      return listOfImgs; \n    },\n\n\n\n\n    /*\n    *Draw the background.\n    *Make it fit in the viewport\n    */\n\n    _drawBG : function (img) {\n      var ctx = this.get('ctx'),\n      width = img.width,\n      height = img.height,\n      ratio = this.get('bgRatio');\n      ctx.drawImage(img, 0, 0, width * ratio, height * ratio );\n      ctx.save();\n      ctx.scale(ratio,ratio);\n      ctx.drawImage(img, 0, 0);\n      ctx.restore();\n    },\n\n    /**\n    *Draw the whole canvas with bg, primary and secondary img\n    * whose index is passed as arg\n    */\n    _drawScene : function (bgIndex, imgsIndex){\n      Y.log('_drawScene: ' + bgIndex + ', ' + imgsIndex);\n      var img = this.get('listOfBGs')[bgIndex];\n\n      var imgName = img.name;\n      img = img.node.getDOMNode(),\n      ratio = this.computeRatio(img.width, img.height, this.get('width'), this.get('height'));\n      this.set('bgRatio', ratio);\n      this._drawWhiteBlank();\n      var bgInfo = this.get('listOfBGs')[bgIndex];\n\n      //for each frame, draw the corresponding current img\n      Y.Array.each(bgInfo.coord, function(coord, frameNumber) {\n        var imgIndex = imgsIndex[frameNumber] || 0;\n        var img = this.get('listOfImgs')[frameNumber][imgIndex];\n        this._drawImage(img, frameNumber);\n      }, this);\n      this._drawBG(img);\n\n    },\n\n\n    /**\n    *Draw the whole canvas with bg, primary and secondary img\n    * whose index is passed as arg\n    */\n    _drawSceneOld : function (bgIndex, primImgIndex, secImgIndex){\n      Y.log('_drawScene: ' + bgIndex + ', ' + primImgIndex + ', ' + secImgIndex);\n      var img = this.get('listOfBGs')[bgIndex];\n\n      var imgName = img.name;\n      img = img.node.getDOMNode(),\n      ratio = this.computeRatio(img.width, img.height, this.get('width'), this.get('height'));\n      this.set('bgRatio', ratio);\n\n      this._drawWhiteBlank();\n      this._drawImage(this.get('listOfPrimImgs')[primImgIndex], 0);\n      this._drawImage(this.get('listOfSecImgs')[secImgIndex], 1);\n      this._drawBG(img);\n\n    },\n\n    /*\n    *erase the whole canvas\n    */\n    _drawWhiteBlank: function() {\n      var ctx = this.get('ctx');\n      Y.log('drawWithBlank');\n      ctx.clearRect(0, 0, this.get('width') , this.get('height') );\n\n    },\n\n    /**\n    *draw an image, at the position and angle \n    * specified by the BG information\n    */\n    _drawImage : function (img, frameNumber) {\n      var ctx = this.get('ctx'),\n      ratio = this.get('bgRatio'),\n      bgIndex = this.get('currentBG'),\n      bg=this.get('listOfBGs')[bgIndex],\n      frameNumber = frameNumber || 0;\n\n      var transX = bg.coord[frameNumber].x,\n      transY = bg.coord[frameNumber].y,\n      photoframe_width = bg.coord[frameNumber].width,\n      photoframe_height = bg.coord[frameNumber].height,\n      img = img.node.getDOMNode(), \n      angle = bg.coord[frameNumber].angle;\n      //setup the context, \n      //scale according to the bg scale\n      //translate to the photo frame position\n      //and rotate like the photo frame\n      //finally we clip to the size of thphoto frame\n      ctx.save();\n      ctx.scale(ratio, ratio);\n      ctx.translate(transX, transY);\n      ctx.rotate(angle);\n\n      ctx.beginPath();\n      ctx.lineTo(photoframe_width, 0);\n      ctx.lineTo(photoframe_width, photoframe_height);\n      ctx.lineTo(0, photoframe_height);\n      ctx.lineTo(0, 0);\n      ctx.clip();\n\n      ratio = this.computeRatio(img.width, img.height, photoframe_width, photoframe_height);\n      var framesRatio = this.get('imgsRatio'),\n      frameR = framesRatio[frameNumber];\n      if (Y.Lang.isUndefined(frameR)){\n        frameR = 1;\n        framesRatio[frameNumber] = frameR;\n        this.set('imgsRatio', framesRatio);\n      }\n      ratio = ratio * frameR;\n      ctx.scale(ratio, ratio);\n      ctx.drawImage(img, 0, 0);\n      ctx.restore(); \n    },\n    /**\n    *draw an image, at the position and angle \n    * specified by the BG information\n    */\n    _drawImageOld : function (img, frameNumber) {\n      var ctx = this.get('ctx'),\n      ratio = this.get('bgRatio'),\n      bgIndex = this.get('currentBG'),\n      bg=this.get('listOfBGs')[bgIndex],\n      frameNumber = frameNumber || 0;\n\n      var frameName = ['prim', 'sec'][frameNumber],\n      coord = frameName + 'Coord', \n      ratioName = frameName + 'ImgRatio',\n      transX = bg[coord].x,\n      transY = bg[coord].y,\n      photoframe_width = bg[coord].width,\n      photoframe_height = bg[coord].height,\n      img = img.node.getDOMNode(), \n      angle = bg[coord].angle;\n      //setup the context, \n      //scale according to the bg scale\n      //translate to the photo frame position\n      //and rotate like the photo frame\n      //finally we clip to the size of thphoto frame\n      ctx.save();\n      ctx.scale(ratio, ratio);\n      ctx.translate(transX, transY);\n      ctx.rotate(angle);\n\n      ctx.beginPath();\n      ctx.lineTo(photoframe_width, 0);\n      ctx.lineTo(photoframe_width, photoframe_height);\n      ctx.lineTo(0, photoframe_height);\n      ctx.lineTo(0, 0);\n      ctx.clip();\n\n      ratio = this.computeRatio(img.width, img.height, photoframe_width, photoframe_height);\n      ratio = ratio * this.get(ratioName);\n      ctx.scale(ratio, ratio);\n      ctx.drawImage(img, 0, 0);\n      ctx.restore(); \n    },\n\n    computeRatio : function (x,y,xref,yref){\n      Y.log('computeRatio ' + x + ',' + y +', ' + xref + ', ' + yref);\n      var xRatio = xref / x,\n      yRatio = yref / y,\n      ratio = 1;\n\n\n      if (xRatio < 1 || yRatio < 1) {\n        //we need to reduce size of img\n        ratio = (xRatio < yRatio)? xRatio : yRatio; \n      } \n      return ratio;\n\n    },\n\n    nextBG : function() {\n\n      var nextBG = this.get('currentBG') + 1;\n      if (nextBG >= this.get('listOfBGs').length){\n        nextBG = 0;\n      }\n      this.set('currentBG', nextBG);\n      this.set('selectedFrame', 0);\n      Y.log('New BG is ' + nextBG);\n\n    },\n\n    nextCurrentFrameImg : function() {\n\n      var selectedFrame = this.get('selectedFrame');\n      var currentFrameImgs =  this.get('currentFrameImgs'),\n      currentFrameImg = currentFrameImgs[selectedFrame];\n      if (Y.Lang.isUndefined(currentFrameImg)) {\n        currentFrameImg = 1;\n      } else {\n        currentFrameImg ++;\n      } \n      if (currentFrameImg >= this.get('listOfImgs')[selectedFrame].length){\n        currentFrameImg = 0;\n      }\n      currentFrameImgs[selectedFrame] = currentFrameImg;\n      this.set('currentFrameImgs', currentFrameImgs);\n      Y.log('New Img for frame ' + selectedFrame +' is ' + currentFrameImg);\n    },\n\n    /*\n    *switch between the frames 0 and 1\n    */\n    nextFrame : function() {\n      var prev = this.get('selectedFrame');\n      var currentBG = this.get('currentBG') ;\n      var numberOfFrameInBG = this.get('listOfBGs')[currentBG].coord.length;\n      this.set('selectedFrame', ((prev + 1 < numberOfFrameInBG )?prev+1:0)); \n      Y.log('Next Frame: ' + this.get('selectedFrame'));\n    },\n\n\n    primImgZoomHandler : function(scrollEvt){\n      var delta = 0.01 *scrollEvt.wheelDelta,\n      ratio = this.get('primImgRatio');\n      Y.log('new primImgRatio = ' + ratio);\n      this.set('primImgRatio', ratio+delta);\n    },\n\n\n    secImgZoomHandler : function(scrollEvt){\n      var delta = 0.01 *scrollEvt.wheelDelta,\n      ratio = this.get('secImgRatio');\n      Y.log('new secImgRatio = ' + ratio);\n      this.set('secImgRatio', ratio+delta);\n    },\n\n    selectedFrameZoomHandler : function(evt) {\n      [this.primImgZoomHandler ,this.secImgZoomHandler][this.get('selectedFrame')].call(this, evt);\n    },\n\n    /**\n    *Find what element of the thanks card the click was.\n    * It can be the background, an image frame or other\n    * In case it is an image frame the index of the frame will be returned too\n    *\n    *@method getElementClicked\n    *@param {number} x x coordinate of the mouse click\n    *@param {number} y y coordinate of the mouse click\n    */\n    getElementClicked: function(x, y) {\n      Y.log('Finding what element was clicked on x' + x + '/y' + y);\n      var framesCoords = this.get('listOfBGs')[this.get('currentBG')].coord;\n      var clickedFrameIndex = (Y.Array.map(framesCoords, isInFrame, {x: x, y: y, that:this})).indexOf(true);\n      \n\n      function isInFrame(coord, index, a ) {\n        var that = this.that,\n        ctx = that.get('ctx'),\n        ratio = that.get('bgRatio'),\n        transX = coord.x,\n        transY = coord.y,\n        photoframe_width = coord.width,\n        photoframe_height = coord.height,\n        angle = coord.angle;\n        //setup the context, \n        //scale according to the bg scale\n        //translate to the photo frame position\n        //and rotate like the photo frame\n        //finally we clip to the size of thphoto frame\n        ctx.save();\n        ctx.scale(ratio, ratio);\n        ctx.translate(transX, transY);\n        ctx.rotate(angle);\n\n        ctx.beginPath();\n        ctx.lineTo(photoframe_width, 0);\n        ctx.lineTo(photoframe_width, photoframe_height);\n        ctx.lineTo(0, photoframe_height);\n        ctx.lineTo(0, 0);\n        ctx.stroke();\n        ctx.restore();\n        var isInPath = ctx.isPointInPath(this.x, this.y)\n        Y.log('Point is in frame ' + index + ' : ' + isInPath); \n        return isInPath;\n      }\n      return clickedFrameIndex;\n    },\n\n    onClick: function(e) {\n      var container = this.get('srcNode'),\n      x = e.pageX - container.getX(),\n      y = e.pageY - container.getY();\n\n      var elClick = this.getElementClicked(x,y);\n      if (elClick < 0) {\n       this.nextBG();\n      } else {\n       this.set('selectedFrame', elClick);\n       this.nextCurrentFrameImg();\n      }\n    }\n\n  });\n\n  Y.namespace(\"Thx\").ThanksCard = ThanksCard;\n\n  // }, \"3.2.0\", {requires:[\"widget\", \"substitute\"]});\n  // END WRAPPER\n\n\n  Y.on('domready', function(){\n    //we hide the 'waiting' element and show the thx_card container\n    Y.one('#waiting').addClass('hidden');\n    Y.one('#container').removeClass('hidden');\n    var thx = new ThanksCard({\n      srcNode: \"#container\",\n      listOfBGs :[\n        {\n          name: 'test1',\n          node: Y.one('#bg_img2'),\n          coord: [{x:525, y:250, width:595, height: 600, angle:0.261},\n          {x:1249, y:240, width:595, height: 525, angle:0.174}]\n        },\n        {\n          name: 'test2',\n          node: Y.one('#bg_img1'),\n          coord: [{x:210, y:305, width:320, height: 310, angle:0},\n          {x:1185, y:448, width:470, height: 475, angle:0}]\n        }]\n    });\n\n\n    Y.log('Thx card inited\\nset list of imgs...');\n    var photoClasses = ['.primPhoto', '.secPhoto'];\n    thx.set('listOfImgs', photoClasses);\n    thx.render();\n    Y.one('body').on('key', function (e) {\n      thx.nextFrame();\n    }, 'down:enter');\n\n    Y.one('body').on('key', function (e) {\n      e.preventDefault();\n      thx.nextCurrentFrameImg();\n    }, 'down:tab');\n\n    Y.one('body').on('key', function (e) { \n      thx.nextBG();\n      e.stopPropagation();\n    }, 'down:+shift');\n    Y.one('body').on('mousewheel', function (e) { \n      Y.log('event mousewheel'); \n      thx.selectedFrameZoomHandler(e);\n    });\n\n    Y.one('#container').on('click', thx.onClick, thx)\n\n    Y.one('body').focus();\n\n\n  });\n});"],[0,"\n"]],"start1":528,"start2":528,"length1":16207,"length2":19477}]],"length":20005,"saved":false}
